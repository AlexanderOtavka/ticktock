<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="gapi-manager.html">

<script>
/* globals GAPIManager */

(function () {
'use strict';

//
// API configuration
//

GAPIManager.setClientId(
  '208366307202-00824keo9p663g1uhkd8misc52e1c5pa.apps.googleusercontent.com');
GAPIManager.setScopes([
  'https://www.googleapis.com/auth/userinfo.email',
  'https://www.googleapis.com/auth/plus.me',
  'https://www.googleapis.com/auth/calendar.readonly',
]);

var LOCAL_API_ROOT = '//' + window.location.host + '/_ah/api';
var loadedTickTockAPI = GAPIManager.loadAPI('ticktock', 'v1', LOCAL_API_ROOT);
var loadedOauth2API = GAPIManager.loadAPI('oauth2', 'v2');

//
// Constants
//

var SIGNED_OUT_USER_INFO = {
  name: 'Sign In with Google',
  picture: '/images/google-logo.svg',
  loading: false,
  signedOut: true,
};
var LOADING_USER_INFO = {
  name: 'Loading...',
  picture: '',
  loading: true,
  signedOut: false,
};

var ALL_CALENDAR = {
  name: 'All Calendars',
  calendarId: '*',
  color: '#e91e63',
  icon: 'ticktock:calendar-multiple',
  noMenu: true,
  eventsErrored: false,
  eventsLoading: true,
  calendarErrored: false,
  calendarLoading: false,
  hidden: false,
  events: [],
  nextPageToken: null,
};

//
// Static Variables
//

var _calendars = {
  all: [ALL_CALENDAR],
  unhidden: [ALL_CALENDAR],
};

var _calendarsLoading = true;

//
// Element registration
//

Polymer({
  is: 'api-manager',

  properties: {
    userInfo: {
      type: Object,
      notify: true,
      value: LOADING_USER_INFO,
    },
    calendars: {
      type: Object,
      notify: true,
      value: function () {
        return [ALL_CALENDAR];
      },
    },
    hasHiddenCalendars: {
      type: Boolean,
      notify: true,
      readOnly: true,
      value: false,
    },
    showHiddenEvents: {
      type: Boolean,
    },
    showHiddenCalendars: {
      type: Boolean,
    },
  },

  observers: [
    '_calendarsChanged(calendars.*)',
  ],

  _calendarsChanged: function (changeRecord) {
    var allCalendarIndex = this.calendars.indexOf(ALL_CALENDAR);
    var calendarsSplicesRE = new RegExp('^calendars$');
    // var calendarEventsSplicesRE =
    //   new RegExp('^calendars\\.#(?!' + allCalendarIndex + ')\\d+\\.events$');
    var calendarStateRE =
      new RegExp('^calendars\\.#(?!' + allCalendarIndex + ')\\d+\\.' +
                 '(hidden|eventsErrored|eventsLoading)$');

    if (calendarsSplicesRE.test(changeRecord.path)) {
      this._updateAllCalendarState();
      this._updateAllCalendarEvents();
    } else if (calendarStateRE.test(changeRecord.path)) {
      this._updateAllCalendarState();
    }
  },

  /**
   * Authenticate the user and do an initial load.
   *
   * @param {Boolean} mode - True suppresses the popup and uses the cookie.
   */
  signIn: function (mode) {
    this._authorize(mode)
      .then(this._loadAllData.bind(this))
      .catch(logError);
  },

  /**
   * Remove all signed in UI.
   */
  signOut: function () {
    this.userInfo = SIGNED_OUT_USER_INFO;
    this.calendars = [];

    // TODO: actually sign the user out
  },

  /**
   * Clear cache and reload events for given calendar.
   *
   * @param {Object} calendar - Calendar data object to be reloaded.
   */
  reloadEvents: function (calendar) {
    if (calendar.calendarErrored ||
        calendar.eventsLoading ||
        this.userInfo.signedOut) {
      return;
    }

    var calendars;
    if (calendar === ALL_CALENDAR) {
      calendars = this.calendars;
    } else {
      calendars = [calendar];
    }

    this._loadEvents(calendars)
      .catch(logError);
  },

  /**
   * Update event's data on the server.
   *
   * @param {Object} params - Calendar and event ids as well as new starred
   *   and/or hidden state.
   */
  patchEvent: function (params) {
    this._singleSortEvent(params.eventId, params.calendarId);
    this._sendReAuthedRequest(loadedTickTockAPI
      .then(function (ticktock) {
        return ticktock.events.patch({
          calendarId: encodeURIComponent(params.calendarId),
          eventId: params.eventId,
          starred: params.starred,
          hidden: params.hidden,
        });
      }))
      .catch(this._handleHTTPError.bind(this))
      .catch(logError);
  },

  /**
   * Update calendar's data on the server.
   *
   * @param {Object} params - Calendar id and new hidden state.
   */
  patchCalendar: function (params) {
    var calendar = this.getCalendarById(params.calendarId);
    var calendarKey = this._getCalendarKey(calendar);
    var allCalendarKey = this._getCalendarKey(ALL_CALENDAR);

    calendar.events.forEach((function (calendarEvent, i) {
      this.set(['calendars', calendarKey, 'events', i, 'calendarHidden'],
               calendar.hidden);
    }).bind(this));

    ALL_CALENDAR.events.forEach((function (calendarEvent, i) {
      if (calendarEvent.calendarId === calendar.calendarId) {
        this.notifyPath(
          ['calendars', allCalendarKey, 'events', i, 'calendarHidden'],
          calendarEvent.calendarHidden);
      }
    }).bind(this));

    this._sendReAuthedRequest(loadedTickTockAPI
      .then(function (ticktock) {
        return ticktock.calendars.patch({
          calendarId: encodeURIComponent(params.calendarId),
          hidden: params.hidden,
        });
      }))
      .catch(this._handleHTTPError.bind(this))
      .catch(logError);
  },

  getCalendarById: function (calendarId) {
    var foundCalendar = _calendars.all.find(function (calendar) {
      return calendar.calendarId === calendarId;
    });

    return foundCalendar || this._makeProxyCalendar(calendarId);
  },

  deleteEventById: function (calendarId, eventId) {
    var calendar = this.getCalendarById(calendarId);
    var i;

    i = getEventIndexById(calendar, eventId);
    if (i !== -1) {
      var calendarKey = this._getCalendarKey(calendar);
      this.splice(['calendars', calendarKey, 'events'], i, 1);
    }

    i = getEventIndexById(ALL_CALENDAR, eventId, calendarId);
    if (i !== -1) {
      var allCalendarKey = this._getCalendarKey(ALL_CALENDAR);
      this.splice(['calendars', allCalendarKey, 'events'], i, 1);
    }
  },

  _getCalendarKey: function (calendar) {
    return Polymer.Collection.get(this.calendars).getKey(calendar);
  },

  _authorize: function (mode) {
    return GAPIManager.authorize(mode)
      .then((function () {
        this.userInfo = LOADING_USER_INFO;
      }).bind(this))
      .catch((function (err) {
        if (err instanceof GAPIManager.AuthError && err.accessDenied) {
          this.signOut();
        }

        throw err;
      }).bind(this));
  },

  _loadAllData: function () {
    return Promise.all([
      this._loadProfile()
        .catch(this._handleHTTPError.bind(this)),
      this._loadCalendars()
        .then(this._loadEvents.bind(this))
        .catch(this._handleHTTPError.bind(this)),
    ]);
  },

  _loadProfile: function () {
    return this._sendReAuthedRequest(loadedOauth2API
      .then(function (oauth2) {
        return oauth2.userinfo.v2.me.get({
          fields: 'name,picture',
        });
      }))
      .then((function (resp) {
        resp.loading = false;
        resp.signedOut = false;
        this.userInfo = resp;
      }).bind(this));
  },

  _loadCalendars: function () {
    _calendarsLoading = true;
    return this._sendReAuthedRequest(loadedTickTockAPI
      .then(function (ticktock) {
        return ticktock.calendars.list({
          hidden: null,
        });
      }))
      .then((function (resp) {
        var hasHiddenCalendars = false;
        var calendars = resp.items || [];
        calendars.forEach((function (calendar, i) {
          var duplicateKey;
          var duplicateIndex = _calendars.all.findIndex(
            function (loadingCalendar) {
              return loadingCalendar.calendarId === calendar.calendarId;
            });

          if (duplicateIndex !== -1) {
            var duplicate = _calendars.all.splice(duplicateIndex, 1)[0];
            duplicateKey = this._getCalendarKey(duplicate);
            updateObject(duplicate, calendar);
            calendar = duplicate;
            calendars.splice(i, 1, calendar);
          }

          updateObject(calendar, {
            calendarErrored: false,
            calendarLoading: false,
            icon: '',
            noMenu: false,
          });

          addObjectFields(calendar, {
            events: [],
            eventsErrored: false,
            eventsLoading: false,
            nextPageToken: null,
          });

          if (calendar.hidden) {
            hasHiddenCalendars = true;
          }

          if (duplicateKey) {
            Object.keys(calendar).forEach((function (key) {
              this.notifyPath(['calendars', duplicateKey, key], calendar[key]);
            }).bind(this));
          }
        }).bind(this));

        this._setHasHiddenCalendars(hasHiddenCalendars);

        _calendarsLoading = false;
        _calendars.all.forEach(function (calendar) {
          if (calendar.calendarLoading) {
            setCalendarToErrorState(calendar);
          }
        });

        this.calendars = _calendars.all = _calendars.all.concat(calendars);

        return calendars;
      }).bind(this));
  },

  _loadEvents: function (calendars) {
    var timeZone;
    try {
      timeZone =  Intl.DateTimeFormat().resolvedOptions().timeZone;
    } catch (err) {
      timeZone = null;
    }

    return Promise.all(calendars.map((function (calendar) {
      var calendarKey = this._getCalendarKey(calendar);
      if (calendarKey) {
        this.set(['calendars', calendarKey, 'events'], []);
        this.set(['calendars', calendarKey, 'eventsErrored'], false);
        this.set(['calendars', calendarKey, 'eventsLoading'], true);
      }

      return this._sendReAuthedRequest(loadedTickTockAPI
        .then(function (ticktock) {
          return ticktock.events.list({
            calendarId: encodeURIComponent(calendar.calendarId),
            hidden: null,
            maxResults: 10,
            timeZone: timeZone,
          });
        }))
        .then((function (resp) {
          calendarKey = this._getCalendarKey(calendar);
          if (resp.items) {
            resp.items.forEach(function (calendarEvent) {
              calendarEvent.color = calendar.color;
              calendarEvent.calendarHidden = calendar.hidden;
            });

            if (calendarKey) {
              this.set(['calendars', calendarKey, 'events'], resp.items);
            }

            sortEvents(calendar);
          }
        }).bind(this))
        .catch((function (err) {
          if (calendarKey) {
            this.set(['calendars', calendarKey, 'eventsErrored'], true);
          }

          throw err;
        }).bind(this))
        .catch(this._handleHTTPError.bind(this))
        .then((function () {
          if (calendarKey) {
            this.set(['calendars', calendarKey, 'eventsLoading'], false);
          }
        }).bind(this));
    }).bind(this)))
      .then(this._updateAllCalendarEvents.bind(this));
  },

  _updateAllCalendarEvents: function () {
    var calendars = _calendars.all.slice();
    var allCalendarIndex = calendars.indexOf(ALL_CALENDAR);
    calendars.splice(allCalendarIndex, 1);

    var events = [];
    calendars.forEach(function (calendar) {
      events = events.concat(calendar.events);
    });

    events = events.sort(compareEvents);
    this.set(['calendars', allCalendarIndex, 'events'], events);
  },

  _updateAllCalendarState: function () {
    var allCalendarIndex = this.calendars.indexOf(ALL_CALENDAR);
    var eventsLoading = (this.calendars.length - 1) ? false : _calendarsLoading;
    var eventsErrored = (this.calendars.length - 1) ? true : false;
    this.calendars.forEach((function (calendar) {
      if (calendar !== ALL_CALENDAR) {
        if (calendar.eventsLoading) {
          eventsLoading = true;
        }

        if (!calendar.eventsErrored) {
          eventsErrored = false;
        }
      }
    }).bind(this));

    this.set(['calendars', allCalendarIndex, 'eventsLoading'], eventsLoading);
    this.set(['calendars', allCalendarIndex, 'eventsErrored'], eventsErrored);
  },

  _handleHTTPError: function (err) {
    if (err instanceof GAPIManager.HTTPError) {
      console.warn(err);
      if (err.code === -1) {
        this.fire('network-error');
      } else if (err.code === 401) {
        this.signOut();
      } else {
        this.fire('error');
      }
    } else {
      throw err;
    }
  },

  _sendReAuthedRequest: function (request) {
    return request
      .catch((function (err) {
        if (err.code === 401) {
          console.warn(err);
          return this.signIn(true)
            .then(function () {
              return request;
            });
        } else {
          throw err;
        }
      }).bind(this));
  },

  /**
   * Move an event to its proper place in its calendar and the ALL_CALENDAR.
   *
   * Uses the insertion sort algorithm, and notifies splices.
   *
   * @param {String} eventId - The event's ID.
   * @param {String} calendarId - The event's calendar's ID.
   */
  _singleSortEvent: function (eventId, calendarId) {
    var calendar = this.getCalendarById(calendarId);
    this._singleSortByCalendar(calendar, eventId);
    if (calendar !== ALL_CALENDAR) {
      this._singleSortByCalendar(ALL_CALENDAR, eventId);
    }
  },

  _singleSortByCalendar: function (calendar, eventId) {
    /************************
    Algorithm Summary Drawing
    *************************
                  *-3
    [1, 6, 9, 15, 19, 22]
        ^
    (1, 3)? yes
       (6, 3)? no

    [1, 6, 9, 15, 3, 19, 22]
            - to -
    [1, 3, 6, 9, 15, 19, 22]
    -----------------------------
        *-16
    [1, 9, 15, 17, 19, 22]
               ^
    (1, 16)? yes
       (9, 16)? yes
          (15, 16)? yes
              (17, 16)? no

    [1, 16, 9, 15, 17, 19, 22]
             - to -
    [1, 9, 15, 16, 17, 19, 22]
    ************************/
    var misplacedIndex = calendar.events.findIndex(function (calendarEvent) {
      return calendarEvent.eventId === eventId;
    });

    if (misplacedIndex === -1) {
      return;
    }

    var misplacedEvent = calendar.events.splice(misplacedIndex, 1)[0];

    var targetIndex = calendar.events.findIndex(function (calendarEvent) {
      return compareEvents(calendarEvent, misplacedEvent) > 0;
    });

    calendar.events.splice(targetIndex, 0, misplacedEvent);

    var calendarKey = this._getCalendarKey(calendar);
    if (calendarKey) {
      this.notifySplices(['calendars', calendarKey, 'events'], [
        {
          index: misplacedIndex,
          removed: [misplacedEvent],
          addedCount: 0,
          object: calendar.events,
          type: 'splice',
        },
        {
          index: targetIndex,
          removed: [],
          addedCount: 1,
          object: calendar.events,
          type: 'splice',
        },
      ]);
    }
  },

  _makeProxyCalendar: function (calendarId) {
    var proxy = {
      name: 'TickTock',
      calendarId: calendarId,
      color: '#e91e63',
      icon: '',
      noMenu: false,
      eventsErrored: false,
      eventsLoading: true,
      calendarErrored: false,
      calendarLoading: true,
      hidden: false,
      events: [],
      nextPageToken: null,
    };

    if (!_calendarsLoading) {
      setCalendarToErrorState(proxy);
    }

    _calendars.all.push(proxy);
    this.push('calendars', proxy);
    return proxy;
  },
});

//
// Utility functions
//

function logError(err) {
  console.error(err);
  throw err;
}

function getEventIndexById(calendar, eventId, calendarId) {
  return calendar.events.findIndex(function (calendarEvent) {
    return calendarEvent.eventId === eventId &&
           calendarEvent.calendarId === (calendarId || calendar.calendarId);
  });
}

function setCalendarToErrorState(calendar) {
  calendar.eventsErrored = true;
  calendar.eventsLoading = false;
  calendar.calendarErrored = true;
  calendar.calendarLoading = false;
}

// function updateListedCalendars() {
//   if (app.userInfo.signedOut) {
//     app.listedCalendars = [];
//     app.hasHiddenCalendars = false;
//     return;
//   }
//
//   if (app.selectedCalendar.hidden) {
//     app.showHiddenCalendars = true;
//   }
//
//   var hasHidden = false;
//   var listed = [];
//   app.calendars.forEach(function (calendar) {
//     if (!hasHidden && calendar.hidden) {
//       hasHidden = true;
//     }
//
//     if (!calendar.hidden || app.showHiddenCalendars) {
//       listed.push(calendar);
//     }
//   });
//
//   app.listedCalendars = listed;
//   app.hasHiddenCalendars = hasHidden;
// }

/**
 * Sort all of a calendar's events.
 *
 * Does not notify.
 *
 * @param {Object} calendar - The calendar object whose events should be
 *   sorted.
 */
function sortEvents(calendar) {
  calendar.events = calendar.events.sort(compareEvents);
}

function compareBools(a, b) {
  // True is first.
  return b - a;
}

function compareStrings(a, b) {
  // Sort alphabetically, any language, case insensitive.
  return a.localeCompare(b);
}

function compareEvents(a, b) {
  // Sort order: starred, duration, alphabetical, id.
  return compareBools(a.starred, b.starred) ||
         compareStrings(a.startDate || a.endDate,
                        b.startDate || b.endDate) ||
         compareStrings(a.name, b.name) ||
         compareStrings(a.eventId, b.eventId) ||
         0;
}

function updateObject(object, newValues) {
  Object.keys(newValues).forEach(function (key) {
    object[key] = newValues[key];
  });
}

function addObjectFields(object, fields) {
  var keys = Object.keys(fields);
  keys.forEach(function (key) {
    if (!object.hasOwnProperty(key)) {
      object[key] = fields[key];
    }
  });
}

})();
</script>
